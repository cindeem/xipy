import os, sys
# try loading this generated class from the uic module
## from pyqt4.pyqt4_viewer import Ui_MainWindow
from PyQt4 import uic
design_path = os.path.join(os.path.split(__file__)[0], 'pyqt4/pyqt4_viewer.ui')
ui_layout_class, base_class = uic.loadUiType(design_path)

from PyQt4 import QtCore, QtGui
import matplotlib as mpl
import matplotlib.cm as cm

import numpy as np

from nutmeg.vis.single_slice_plot import SliceFigure, SliceImage, \
     TimeFreqPlaneFigure
from nutmeg.vis import *
from nutmeg.vis import qt4_widgets as qw
from nutmeg.vis import mayavi_widgets
from nutmeg.vis.overlay_manager import ImageOverlayControl
from nutmeg.vis.overlays import overlay_thresholding_factory

interpolations = ['nearest', 'bilinear', 'sinc']
cmaps = cm.cmap_d.keys()
cmaps.sort()

class OrthoViewer(QtGui.QMainWindow, ui_layout_class):
    def __init__(self, image=None, beam=None, overlay=None, fliplr=False,
                 parent=None):
##         QtGui.QMainWindow.__init__(self)
        super(OrthoViewer, self).__init__(parent)

        # if ANALYZE Images are known to be presented in right-handed
        # orientation, then you can forcibly ignore the sign of
        # R[0,0], in the index to world transform
        self._fliplr = fliplr
        
        # kick in the Qt Designer generated layout and signal/slot connections
        self.setupUi(self)
        # kick in the manual connections etc written below
        self.extra_setup_ui()
        self._image_loaded = False
        self._overlay_active = False

        try:
            self.update_image(image)
        except ValueError:
            print 'no image to load in __init__()'
            
        self._aux_children_registry = []
        # Creates TF Plane window and Mayavi 3D view
        self.create_sibling_windows(beam=beam, overlay=overlay)
        # do a little catch up with the informing
        if self._image_loaded:
            self.mayavi_widget.mr_vis.anat_image = self.img
        
##     def closeEvent(self, ev):
##         print 'about to close'
##         QtCore.QCoreApplication.quit()

    def extra_setup_ui(self):

        # set up cmap options
        self.cmap_box.insertItems(0, cmaps)
        self.cmap_box.setCurrentIndex(cmaps.index('gray'))
        #self.img_cmap = property(fget=self.cmap_box.currentText)
        self.o_cmap_box.insertItems(0, cmaps)
        self.o_cmap_box.setCurrentIndex(cmaps.index('jet'))
        #self.overlay_cmap = property(fget=self.o_cmap_box.currentText)
        # set up interp options
        self.interp_box.insertItems(0, interpolations)
        self.interp_box.setCurrentIndex(interpolations.index('nearest'))
        #self.img_interp = property(fget=self.interp_box.currentText)
        self.o_interp_box.insertItems(0, interpolations)
        self.o_interp_box.setCurrentIndex(interpolations.index('bilinear'))
        #self.overlay_interp = property(fget=self.o_interp_box.currentText)

        # connect menu items
        self.actionLoad_MR_File.triggered.connect(self.on_load_mr)
        self.actionLoad_Beam_File.triggered.connect(self.on_load_beam)
        self.actionLoad_Overlay_Image.triggered.connect(self.on_load_overlay)
        self.actionUnload_Overlay.triggered.connect(self.remove_overlay)

        # connect image space buttons
        self.worldspace_button.toggled.connect(self.change_to_world)
        self.voxspace_button.toggled.connect(self.change_to_vox)
        
        # connect variants of position states
        QtCore.QObject.connect(self.ortho_figs_widget,
                               QtCore.SIGNAL("xyz_state(int,int,int)"),
                               self.xyz_position_watcher)
        QtCore.QObject.connect(self.ortho_figs_widget,
                               QtCore.SIGNAL("xyz_state(int,int)"),
                               self.xyz_position_watcher)
        QtCore.QObject.connect(self.ortho_figs_widget,
                               QtCore.SIGNAL("xyz_state(int)"),
                               self.xyz_position_watcher)

    def create_sibling_windows(self, beam=None, overlay=None):
        if beam and overlay:
            w.warn('Both Beam and Image Overlay are requested, going with Beam')
            overlay = None
        if beam:
            func_man = self._launch_tf_window(beam=beam)
        elif overlay:
            func_man = self._launch_overlay_control_window(overlay=overlay)
        else:
            func_man = None
##         # Mayavi 3D Scene
        mayavi_widget = mayavi_widgets.MayaviWidget(
            main_ref=self,
            functional_manager=func_man
            )
        self._aux_children_registry.append(mayavi_widget)
        mayavi_widget.show()
        mayavi_widget.activateWindow()
        self.mwidget_toggle = mayavi_widget.toggle_view_action()
        self.menuView.addAction(self.mwidget_toggle)
        r = mayavi_widget.geometry()
        mayavi_widget.setGeometry(900,100,r.width(),r.height())
        self.mwidget_toggle.setChecked(False)
        self.mayavi_widget = mayavi_widget

    def _launch_tf_window(self, beam=None):
        if hasattr(self, 'timefreqwin'):
            if beam:
                self.timefreqwin.beam_manager.update_beam(beam)
                self.tfwidget_toggle.setChecked(True)
            return self.timefreqwin.beam_manager
        # Time Frequency Plane and Beam Manager widget
        image_connections = (self.triggered_overlay_update,
                                #self.mayavi_widget.tf_update
                             )
        print image_connections
        loc_connections = (self.ortho_figs_widget.update_location,)
        tf_connections = () # currently no tf signal callbacks
        self.timefreqwin = qw.MplQT4TimeFreqWindow(
            tf_connections,
            image_connections,
            loc_connections,
            main_ref=self,
            beam=beam
            )
        self._aux_children_registry.append(self.timefreqwin)
        QtCore.QObject.connect(self.o_cmap_box,
                               QtCore.SIGNAL('currentIndexChanged(QString)'),
                               self.timefreqwin.setCmap)
        QtCore.QObject.connect(self.o_alpha_slider,
                               QtCore.SIGNAL('sliderMoved(int)'),
                               self.timefreqwin.setAlpha)
##         QtCore.QObject.connect(self.animate_tf_button,
##                                QtCore.SIGNAL('clicked()'),
##                                self.initiate_tf_animate)
##         self.timefreqwin.tf_point.connect(self.triggered_overlay_update)
        r = self.timefreqwin.geometry()
        w = r.width(); h = r.height()
        self.timefreqwin.setGeometry(50,100,w,h)

        self.timefreqwin.show()
        self.timefreqwin.activateWindow()
        self.tfwidget_toggle = self.timefreqwin.toggle_view_action()
        self.menuView.addAction(self.tfwidget_toggle)
        return self.timefreqwin.beam_manager

    def _launch_overlay_control_window(self, overlay=None):
        if hasattr(self, 'overlay_win'):
            if overlay:
                self.overlay_win.overlay_manager.update_overlay(overlay)
                self.owin_toggle.setChecked(True)
            return self.overlay_win.overlay_manager
        ovr_con = (self.triggered_overlay_update,)
##         if hasattr(self, 'mayavi_widget'):
##             ovr_con = ovr_con + (self.mayavi_widget.overlay_update,)
        loc_con = (self.ortho_figs_widget.update_location,)
        self.overlay_win = ImageOverlayControl(loc_con, ovr_con,
                                               overlay=overlay,
                                               main_ref=self)
        self._aux_children_registry.append(self.overlay_win)
        QtCore.QObject.connect(self.o_cmap_box,
                               QtCore.SIGNAL('currentIndexChanged(QString)'),
                               self.overlay_win.cbar.change_cmap)
        cmap = self.o_cmap_box.currentText()
        self.overlay_win.cbar.change_cmap(cmap)
        r = self.overlay_win.geometry()
        self.overlay_win.setGeometry(50,100,r.width(),r.height())
        self.overlay_win.show()
        self.overlay_win.activateWindow()
        self.owin_toggle = self.overlay_win.toggle_view_action()
        self.menuView.addAction(self.owin_toggle)
        return self.overlay_win.overlay_manager
##         self.owin_toggle.setChecked(True)

##     def create_docks(self):
##         # TF plane dock and signal/slot connections
##         dock = QtGui.QDockWidget("Time Frequency Plane", self)
##         dock.setAllowedAreas(QtCore.Qt.BottomDockWidgetArea |
##                              QtCore.Qt.RightDockWidgetArea)
##         tf_widget = qw.MplQT4TimeFreqWindow(self)
##         self.timefreqwin = tf_widget
##         dock.setWidget(tf_widget)
##         self.addDockWidget(QtCore.Qt.BottomDockWidgetArea, dock)
##         QtCore.QObject.connect(self.o_cmap_box,
##                                QtCore.SIGNAL('currentIndexChanged(QString)'),
##                                self.timefreqwin.setCmap)
##         QtCore.QObject.connect(self.o_alpha_slider,
##                                QtCore.SIGNAL('sliderMoved(int)'),
##                                self.timefreqwin.setAlpha)
##         QtCore.QObject.connect(self.animate_tf_button,
##                                QtCore.SIGNAL('clicked()'),
##                                self.initiate_tf_animate)
##         self.timefreqwin.tf_point.connect(self.triggered_overlay_update)
##         self.menuView.addAction(dock.toggleViewAction())
##         # Mayavi 3D Scene
##         dock = QtGui.QDockWidget("3D Views", self)
##         dock.setAllowedAreas(QtCore.Qt.BottomDockWidgetArea |
##                              QtCore.Qt.RightDockWidgetArea)
##         mayavi_widget = mayavi_widgets.MayaviWidget(parent=self)
##         dock.setWidget(mayavi_widget)
##         self.addDockWidget(QtCore.Qt.BottomDockWidgetArea, dock)
##         mayavi_widget = mayavi_widget
        
##         self.menuView.addAction(dock.toggleViewAction())
##         self.timefreqwin.tf_point.connect(mayavi_widget.tf_update)
        

    ########## ACTION/MENU HANDLERS ##########
    def on_load_mr(self, bool):
        fname = qw.browse_files(self, dialog='Select Image File',
                                wildcard='Images (*.nii *.nii.gz *.hdr *.img)')
        if fname:
            self.update_image(fname)

    @with_attribute('_image_loaded')
    def on_load_beam(self, bool):
        fname = qw.browse_files(self, dialog='Select TF Beam File',
                                wildcard='TFBeams (*.mat *.npy *.npz)')
        if fname:
            func_man = self._launch_tf_window(beam=fname)
            self.mayavi_widget.add_toolbar(func_man)

    @with_attribute('_image_loaded')
    def on_load_overlay(self, bool):
        fname = qw.browse_files(self, dialog='Select Image File',
                                wildcard='Images (*.nii *.nii.gz *.hdr *.img)')
        if fname:
            func_man = self._launch_overlay_control_window(overlay=fname)
            self.mayavi_widget.add_toolbar(func_man)

    ########## IMAGE DATA UPDATES ##########
    def update_image(self, image, mode='world'):
        try:
            s_img = load_resampled_slicer(image, fliplr=self._fliplr)
        except ValueError:
            try:
                s_img = load_sampled_slicer(image, fliplr=self._fliplr)
            except ValueError:
                self.img = None
                self._image_loaded = False
                raise
        self.img = s_img
        self._image_loaded = True
        # need to update:
        # slider ranges
        limits = self.img.bbox
        self.update_ranges(limits)
        planes = self.img.cut_image((0,0,0))
        interp = str(self.interp_box.currentText())
        cmap = cm.cmap_d[str(self.cmap_box.currentText())]
        self.ortho_figs_widget.initialize_plots(planes, (0,0,0), limits,
                                                interpolation=interp,
                                                cmap=cmap)
        if hasattr(self, 'mayavi_widget'):
            self.mayavi_widget.mr_vis.anat_image = self.img

##     @QtCore.pyqtSlot(QtCore.QObject, float, float, float)
    def triggered_overlay_update(self, *args):
        # query obj for the image and the norm (and probably the cmap in future)
        obj = args[0]
        self._overlay_thresholding = overlay_thresholding_factory(
            obj.threshold, positive=False
            )
        self.update_overlay_slices(obj.overlay,
                                   norm=mpl.colors.normalize(*obj.norm))

    @with_attribute('_image_loaded')
    def update_overlay_slices(self, overlay, **kwargs):
        main_limits = self.img.bbox
        try:
            o_img = load_sampled_slicer(overlay, bbox=main_limits)
        except ValueError:
            try:
                o_img = load_resampled_slicer(overlay, bbox=main_limits)
            except ValueError:
                self._overlay_active = False
                self.over_img = None
                raise
        loc = self.ortho_figs_widget.active_voxel
        fx = self._overlay_thresholding
        planes = [np.ma.masked_where(fx(x), x, copy=False)
                  for x in o_img.cut_image(loc)]        
        self.over_img = o_img
        self._overlay_active = True
        limits = self.over_img.bbox
        interp = str(self.o_interp_box.currentText())
        cmap = cm.cmap_d[str(self.o_cmap_box.currentText())]
        norm = kwargs.get('norm', None)
        self.ortho_figs_widget.initialize_overlay_plots(planes, limits,
                                                        interpolation=interp,
                                                        cmap=cmap,
                                                        **kwargs)
        self.check_max_extents()

##     @with_attribute('_image_loaded')        
##     def update_tfplane(self, beam):
##         "Updates the docked TF Plane widget with a new beam"
##         # let the potential exception in load_beam propagate here?
##         beam = load_beam(beam)
##         self.timefreqwin.update_tfbeam(beam)
##         self.timefreqwin.activate()
##         n_bands = len(self.timefreqwin.beam.bands)-1
##         self.tf_band_spinner.setRange(0, n_bands)

##     def initiate_tf_animate(self):
##         band_idx = self.tf_band_spinner.value()
##         self.timefreqwin.animate_over_time(band_idx)
    
##     def remove_tfwindow(self):
##         print 'unloading beam overlays'
##         self.ortho_figs_widget.unload_overlay_plots(draw=True)
##         del self.tf_window

    @with_attribute('_overlay_active')
    def remove_overlay(self, bool):
        print 'unloading MR overlays'
        self.ortho_figs_widget.unload_overlay_plots(draw=True)
        del self.over_img
        self._overlay_active = False
        if hasattr(self, 'timefreqwin'):
            self.timefreqwin.deactivate(strip_overlay=True)
        if hasattr(self, 'overlay_win'):
            self.overlay_win.deactivate(strip_overlay=True)

    def change_to_world(self, active):
        if active:
            self.change_image_space('world')
    def change_to_vox(self, active):
        if active:
            self.change_image_space('voxel')
        
    @with_attribute('_image_loaded')
    def change_image_space(self, mode):
##         self.img.switch_mode(mode)
        print 'this is broken'
        return
        self.update_image(self.img)
        if self._overlay_active:
            self.over_img.update_target_space(self.img)
            self.update_overlay_slices(self.over_img)
            
        # NEED TO TEST THIS
        #self.check_max_extents()
        limits = self.img.bbox
        self.update_ranges(limits)

    ########## FIGURE/PLOTTING UPDATES ##########
    @with_attribute('_image_loaded')
    def check_max_extents(self):
        limits = self.img.bbox
        self.update_ranges(limits)
        return limits

    def cut_to_location(self, loc):
        pass

##     def _new_vox(self, loc):
##         vsize = np.asarray(self.img.grid_spacing)
##         loc = np.asarray(loc)
##         dist = np.abs(loc - self.__saved_loc)
##         print 'main loc:', loc, self.__saved_loc, dist, vsize        
##         if (np.abs(loc - self.__saved_loc) > vsize).any():
##             self.__saved_loc = loc
##             return True
##         return False
    
##     def _new_overlay_slices(self, loc):
##         # could implement caching or movement thresholding someday
##         if not self._overlay_active:
##             return        
## ##         vsize = np.asarray(self.over_img.grid_spacing)
## ##         loc = np.asarray(loc)
## ##         dist = np.abs(loc-self.__saved_over_loc)
## ##         print 'overlay loc:', loc, self.__saved_over_loc, dist, vsize
## ##         if (dist > vsize).any():
## ##             self.__saved_over_loc = loc
## ##             return True
## ##         return False
    
    @QtCore.pyqtSlot(int, int, int)
    @QtCore.pyqtSlot(int, int)
    @QtCore.pyqtSlot(int)
    def xyz_position_watcher(self, *args):
        axes = args
        xyz_loc = self.ortho_figs_widget.active_voxel
##         if self._new_vox(xyz_loc):
        self.update_fig_data(xyz_loc, axes=axes)

    @with_attribute('_image_loaded')
    def update_fig_data(self, xyz_loc, axes=(SAG, COR, AXI)):
        planes = self.img.cut_image(xyz_loc, axes=axes)
        if self._overlay_active: # and self._new_overlay_vox(xyz_loc):
            fx = self._overlay_thresholding
            o_planes = [np.ma.masked_where(fx(x), x, copy=False)
                        for x in self.over_img.cut_image(xyz_loc, axes=axes)]
            planes = zip(planes, o_planes)
            self.ortho_figs_widget.update_plot_data(
                planes, fig_labels=axes
                )
        else:
            self.ortho_figs_widget.update_main_plot_data(
                planes, fig_labels=axes
                )

    @with_attribute('_image_loaded')
    def update_ranges(self, limits):
        sliders = [self.sag_slider, self.cor_slider, self.axi_slider]
        spinners = [self.sag_spinner, self.cor_spinner, self.axi_spinner]
        for slider, spinner, lim in zip(sliders, spinners, limits):
            slider.setMinimum(lim[0]); slider.setMaximum(lim[1])
            slider.setSliderPosition(0)
            spinner.setRange(lim[0], lim[1])
            spinner.setSingleStep(1)

    def _do_rand_data(self):
        rand_data = [np.random.randn(10,10) for x in [0,1,2]]
        interp = str(self.interp_box.currentText())
        cmap = cm.cmap_d[str(self.cmap_box.currentText())]
        plot_limits = [(-50,50)]*3
        self.ortho_figs_widget.initialize_plots(rand_data, (0,0,0),
                                                plot_limits,
                                                interpolation=interp,
                                                cmap=cmap)
        self.update_ranges(plot_limits)


def ortho_viewer(image=None, overlay=None, beam=None,
                 fliplr=False):
##     app = QtGui.QApplication(sys.argv)
##     image = load_resampled_slicer(image, mask=mask_image, fliplr=fliplr)
##     over_image = load_resampled_slicer(image, mask=True)
    win = OrthoViewer(image=image, overlay=overlay, beam=beam, fliplr=fliplr)
##     win.show()
##     app.exec_()
    return win

def view_mr(mr_image, over_image=None, fliplr=False):
    return ortho_viewer(image=mr_image, overlay=over_image, fliplr=fliplr)

def view_beam(beam, flipstruct=False, display=True):
##     mr_image = str(beam.coreg['mripath'][0])
##     mr_image = str(beam.coreg['mripath'])
    mr_image = beam.coreg.mrpath
    print 'beam MR:', mr_image
    win = ortho_viewer(image=mr_image, beam=beam, fliplr=flipstruct)
    if display:
        win.show()
        if QtGui.QApplication.startingUp():
            app = QtGui.QApplication([])
            app.exec_()

if __name__=='__main__':
    from PyQt4 import QtGui
    
    if QtGui.QApplication.startingUp():
        app = QtGui.QApplication(sys.argv)
    else:
        app = QtGui.QApplication.instance()    
    if len(sys.argv) > 1:
        image = sys.argv[1]
    else:
        image = None
    if len(sys.argv) > 2:
        beam = sys.argv[2]
    else:
        beam = None
    win = OrthoViewer(image=image, beam=beam)
    if not image:
        win._do_rand_data()
    win.show()
    sys.exit(app.exec_())
