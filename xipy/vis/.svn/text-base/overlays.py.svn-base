from enthought.traits import api as t_api
from nipy.core import api as ni_api
from nutmeg.vis.image_slicers import VolumeSlicerInterface
import numpy as np

# XYZ: SHOULD MAKE A TEST CLASS TO PROBAR ANY INSTANCE OF THIS INTERFACE
class OverlayInterface(t_api.HasTraits):
    """Different overlay managers will implement this interface
    """

    # an instance maybe?
    overlay = t_api.Instance(VolumeSlicerInterface)

    # an event to say the overlay is updated
    overlay_updated = t_api.Event

    # the min/max value of the overlay to map to colors
    #norm = t_api.Tuple((0,1))
    norm = (0,1)

    # the alpha channel function for the colormap
##     alpha = t_api.Array(shape=(256,), dtype='b')
    def alpha(self, scale=1.0):
        raise NotImplementedError

    # thresholding information.. masks plotting of the overlay function
    # above/below a scalar value: for instance a plotter could set
    # the alpha channel to zero for scalar values less than 0 
    threshold = t_api.Tuple((0.0, 'inactive'))

    # negative masking function for the overlay array (True=masked,
    # np.MaskedArray convention). This might be used for a priori mask
    # definitions, or masking based on a different array
    # XYZ: THIS SHOULD ALREADY BE A PROPERTY (IF APPLICABLE) OF THE OVERLAY
##     mask = t_api.Array(dtype='B')

    # fill value if using masked arrays
    fill_value = t_api.Float(0.0)

    # additional signal names, and lookup table
    _stats_maps = t_api.List
    stats_map = t_api.Enum(values='_stats_maps')
    stats_map_arrays = {}

    def stats_overlay(self, stat_name):
        """Return a VolumeSlicer type for the requested stats map.
        It is assumed that the map has the same voxel to world mapping
        as the current overlay.

        Parameters
        ----------
        stat_name : str
            The name of the stats mapping to return as a VolumeSlicer type

        Returns
        -------
        a VolumeSlicerInterface subclass (of the same type as the
        current overlay)
        """
        if self.overlay is None:
            print 'Overlay not yet loaded'
            return None
        if stat_name not in self._stats_maps:
            print 'Stats array not loaded:', stat_name
            return None
        oclass = type(self.overlay)
        data = self.stats_map_arrays[stat_name]
        cmap = self.overlay.coordmap
        bbox = self.overlay.bbox # ???
        return oclass(ni_api.Image(data, cmap), bbox=bbox)

    
def overlay_panel_factory(overlay_manager, parent=None):
    from nutmeg.vis.tfbeam_manager import SignalBeamManager
    from nutmeg.vis.overlay_manager import ImageOverlayManager
    from PyQt4 import QtGui
    if type(overlay_manager) is SignalBeamManager:
        tab = QtGui.QTabWidget(parent)
        i = tab.addTab(overlay_manager.edit_traits(
            parent=parent,
            kind='subpanel').control,
                       'Beam Manager')
        tab.addTab(overlay_manager.bstats_manager.edit_traits(
            parent=parent,
            kind='subpanel'
            ).control,
                   'Stats Manager')
        tab.setCurrentIndex(i)
        return tab
    elif type(overlay_manager) is ImageOverlayManager:
        ui = overlay_manager.edit_traits(parent=parent, kind='subpanel').control
        return ui
    else:
        print "Don't know how to create UI panel for this overlay manager type:", overlay_manager


def overlay_thresholding_factory(threshold, positive=True):
    """ Take the OverlayInterface threshold parameters and create a
    function that maps from reals to {0,1}.

    Parameters
    ----------
    threshold : len-2 iterable
        the (threshold-value, comparison-type) pair thresholding parameters


    Returns
    -------
    func -- the thresholding function. If positive is False, then the
    function will return a MaskedArray type field, where the points to
    mask evaluate to True
    """
    # from the interface class definition above, there will be 3 values
    # for the thresh type: inactive, less than, greater than
    t = threshold[0]
    if threshold[-1] == 'inactive':
        if positive:
            return lambda x: np.ones(x.shape, 'B')
        return lambda x: np.zeros(x.shape, 'B')
    elif threshold[-1] == 'less than':
        if positive:
            return lambda x: np.less(x,t)
        return lambda x: np.greater_equal(x,t)
    elif threshold[-1] == 'greater than':
        if positive:
            return lambda x: np.greater(x,t)
        return lambda x: np.less_equal(x,t)
    else:
        print 'unrecognized thresholding parameters:', threshold
