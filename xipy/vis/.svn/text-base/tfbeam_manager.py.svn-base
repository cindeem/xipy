import os
os.environ['ETS_TOOLKIT'] = 'qt4'

import numpy as np
from numpy.lib.index_tricks import unravel_index

import matplotlib as mpl

from enthought.traits.api \
    import HasTraits, HasPrivateTraits, Instance, Enum, Dict, Constant, Str, \
    List, on_trait_change, Float, File, Array, Button, Range, Property, \
    cached_property, Event, Bool, Tuple, Int
    
from enthought.traits.ui.api \
    import Item, Group, View, VGroup, HGroup, HSplit, \
    EnumEditor, CheckListEditor, ListEditor, message, ButtonEditor, \
    RangeEditor, Include

## from enthought.traits.ui.file_dialog import open_file

from nutmeg.vis import browse_files, load_beam
from nutmeg.vis.image_slicers import SampledVolumeSlicer, ResampledVolumeSlicer
from nutmeg.vis.volume_utils import maximum_world_distance
from nutmeg.core.beam import signal_array_to_masked_vol
from nutmeg.core import tfbeam
from nutmeg.stats import stats_utils
from nipy.core import api as ni_api
from nipy.core.reference.coordinate_map import compose

fill_values = {
    'F dB': 0,
    'F raw': 1,
    'T test': 0,
    'p val pos (corr)': 1,
    'p val pos (uncorr)' : 1,
    'p val neg (corr)' : 1,
    'p val neg (uncorr)' : 1,
    }

from nutmeg.vis.overlays import OverlayInterface

class SignalBeamManager( OverlayInterface ):
    """ Manages the GUI manipulation of a TFBeam object, including:
        * Extrema localization in partitioned or all dimensions
        * Active to control ratio transforms
        * Reinterpreting data as various other useful types (NIPY Image,
          (MaskedArray, VolumeSlicer type)
    """
    # Signal manipulation--------------------
    _beam_transforms = List
    transforms = Enum(values='_beam_transforms')

    _using_extra_map = Bool(False)
    pextrabutton = Button('Plot')
    resetsignal = Button('Reset Plot')
    # XYZ: NEED TO FIX THIS!
    alt_names = Enum(*tfbeam.TFBeam.signal_transform_names())
    rbutton = Button('Rename')
    lbutton = Button('Load TF Beam')

    # Beam Stats Manager object---------------------------
##     bstats_manager = Property
    bstats_manager = Instance('nutmeg.vis.tfstats_results.StatsBeamList', ())
    #from nutmeg.vis.tfstats_results import StatsBeamList
    
##     bstats_mananger = Instance

    # Peak finding---------------------------
    tf_idx = Tuple((0,0))
    tf_description = Property(depends_on='tf_idx')
    vox_idx = Int(-1)
    ana_xform = Enum('max', 'min', 'absmax')
    # seems that using "extended trait names" in the Range construction
    # requires extended names for both limits (so make a dummy trait _one)
    _one = Int(1)

    
    #### THIS SECTION IN FLUX BECAUSE OF A POSSIBLE BUG IN TRAITS
    #### WHERE PROPERTIES CONTINUALLY GET RECOMPUTED WHEN THERE ARE
    #### HIDDEN VIEW ELEMENTS. LAME!

    # Extrema in all dimensions
    _num_alldim_features = Int(150)
    all_order = Range('_one', '_num_alldim_features')
    all_button = Button('Locate In All Dimensions')
##     ordered_idx_alldim = Property(Array)
    _ordered_idx_alldim = Array(dtype='uint')
    recompute_all_order = Bool(True) # reset every time work_arr is recomputed

    # Extrema in spatial dimensions
    _num_spatial_features = Int(150)
    spatial_order = Range('_one', '_num_spatial_features')
    spatial_button = Button('Locate In Space')
##     ordered_idx_spatial = Property(Array)
    _ordered_idx_spatial = Array(dtype='uint')
    recompute_spatial_order = Bool(True) # reset every time work_arr is recomputed
    
    # Extrema in TimeFrequency space
    _num_tf_features = Int(150)
    tf_order = Range('_one', '_num_spatial_features')
    tf_button = Button('Locate In Time-Freq')
##     ordered_idx_tf = Property(Array)
    _ordered_idx_tf = Array(dtype='uint')
    recompute_tf_order = Bool(True) # reset every time work_arr is recomputed
    
    # FOV probably not more than 25cm (but could check voxels)
    _max_radius = Float
    _min_radius = Float(0.0)
    radius = Range(value='_max_radius', low='_min_radius', high='_max_radius')
    _good_vox = Array(dtype='ubyte')
    # reset when radius | vox changes (unless radius is at max)
    recompute_good_vox1 = Bool(True)
    recompute_good_vox2 = Bool(True)
    _work_arr = Array(dtype='float64')
    # reset when good_vox, ana_xform, beam_mask changes
    recompute_work_arr = Bool(True)
    
##     good_vox = Property(Array)
##     work_arr = Property(Array)


    # Signal and Mask------------------------
    beam_sig = Property(depends_on=['transforms', 'pextrabutton', 'resetsignal'])
    # beam mask is a negative mask (MaskedArray convention)
    beam_mask = Property(Array, depends_on='_beam_mask, beam_sig')
    _beam_mask = Array(dtype='B')

##     # norm will return a matplotlib.colors.normalize object
##     norm = mpl.colors.normalize(0.0,1.0)

    # Fill value for external masked array handling (eg in Mayavi)
    fill_value = Property(Float)
    _fill_value = Float(np.nan)
    
    def __init__(self, bbox,
                 image_signal=None,
                 loc_signal=None,
                 tf_signal=None,
                 **traits):
        """ Create a SignalBeamManager

        Parameters
        ----------
        bbox : iterable
            the {x,y,z} limits of the enrounding volume box to which TFBeam
            overlays will be mapped.
        loc_signal : QtCore.pyqtSignal
            optional PyQt4 callback signal to emit when peak finding
            (call pattern is loc_signal.emit(x,y,z))
        tf_signal : QtCore.pyqtSignal
            optional PyQt4 callback signal to emit when peak finding,
            (call pattern is tf_signal.emit(time, freq_a, freq_b), where
            [freq_a, freq_b] form the currently selected frequency bracket
        image_signal : QtCore.pyqtSignal
            optional PyQt4 callback signal to emit when updating the image
            (call pattern is image_signal.emit(self))
        """
##         self.l = listening_obj
        self.bbox = bbox
        self.beam = None
        HasTraits.__init__(self, **traits)
        self._image_signal = image_signal
        self._loc_signal = loc_signal
        self._tf_signal = tf_signal
        self._max_radius = np.round(maximum_world_distance(bbox))
        self.__needs_refresh = False
##         from nutmeg.vis.tfstats_results import StatsBeamList
        self.bstats_manager.bman = self # = StatsBeamList(bman=self)

    #-------------------------------------------------------------------------
    ### PROPERTY FETCHERS AND SETTERS.. RUNTIME ATTRIBUTE LOGIC... ETC
        
    def __beam_transforms_default(self):
        return []

    def __stats_maps_default(self):
        return []

##     def _get_bstats_manager(self):
##         return self._bstats_mananger

    @cached_property
    def _get_beam_sig(self):
##         print 'recomputing beam_sig'
        if self._using_extra_map:
            s = self.stats_map_arrays[self.stats_map]
        elif not self.transforms:
            s = np.ones((1,1,1))
        else:
            s = self.beam.s
##         self.norm = mpl.colors.normalize(s.min(), s.max())
        self.norm = (s.min(), s.max())
        return s

    def _set_beam_sig(self):
        # this is purely to make sync_traits happy elsewhere, since
        # "beam_sig" needs to be a read/write trait
        pass

    def _get_fill_value(self):
        signal_type = self.stats_map if self._using_extra_map \
                      else self.transforms        
        return fill_values.get(signal_type, np.nan)
    
##     def __beam_mask_default(self):
##         return np.zeros((1,1,1), np.bool)

    @cached_property
    def _get_beam_mask(self):
##         print 'recomputing beam_mask'
##         print 'grabbing beam_sig from _get_beam_mask'
        sigshape = self.beam_sig.shape
        if self._beam_mask.shape != sigshape:
            #return np.zeros(sigshape, np.bool)
            return None
        else:
            return self._beam_mask

    def _set_beam_mask(self, m):
##         print 'grabbing beam_sig from _set_beam_mask'
        sig = self.beam_sig
        print 'trying to set beam_mask',
##         if sig is None:
##             print 'but no signal yet'
##             return
        if m.shape == sig.shape:
            print 'and succeeded'
            self._beam_mask = m
        else:
            print 'Beam signal shape:',sig.shape,'proposed mask shape',m.shape
            self._beam_mask = np.zeros(sig.shape, dtype='B')

    @cached_property
    def _get_tf_description(self):
        if not self.beam:
            return ''
        t, f = self.tf_idx
        time_pt = self.beam.timepts[t]
        fa, fb = self.beam.bands[f]
        return '(t,f) --> %1.1f ms, [%1.1f Hz - %1.1f Hz] band'%(time_pt,fa,fb)

    #-------------------------------------------------------------------------
    ## THIS SECTION IS A LITTLE CRAZY.. DUE TO A POSSIBLE BUG IN THE
    ## TRAITS UI SYSTEM, SOME PROPERTIES ARE RE-COMPUTED INAPPROPRIATELY
    ## SO THESE ARE A BUNCH OF METHODS THAT ARE NO LONGER PROPERTIES,
    ## BUT PROPERTY-LIKE
    @on_trait_change('beam_sig')
    def _flush_all_cached(self):
        self.recompute_good_vox = True
##         # _good_vox actually should be reset here and now before
##         # the radius slider can get moved around
##         foo = self.good_vox()
        self.recompute_work_arr = True
        self.recompute_all_order = True
        self.recompute_spatial_order = True
        self.recompute_tf_order = True

    ## GOOD (SEARCHED) VOXELS
    @on_trait_change('vox_idx, radius')
    def _set_recompute_good_vox1(self):
        self.recompute_good_vox1 = True
##     @on_trait_change('radius')
##     def _set_recompute_good_vox2(self):
##         self.recompute_good_vox2 = self.radius != self._max_radius

    def good_vox(self):
        cond = self.recompute_good_vox1
        # if not set to recompute, then just return 
        if not cond:
            return self._good_vox
        
        self.recompute_good_vox1 = False
        # Only do work if radius < max_radius, or if there is a vox set.
        if self.vox_idx < 0 or self.radius == self._max_radius:
##             print 'soft computing good_vox'
##             print 'grabbing beam_sig from good_vox'
            self._good_vox = np.ones((len(self.beam_sig),), dtype=np.bool)
            return self._good_vox
##         print 'recomputing good vox'
        xyz = self.beam.voxels[self.vox_idx]
        print 'current vox', xyz, 'current radius:', self.radius
        vdist = ((self.beam.voxels - xyz)**2).sum(axis=-1)
        self._good_vox = vdist <= self.radius**2
        print '# of voxels within radius:', self._good_vox.sum()
        return self._good_vox

    ## WORK ARRAY -- USED FOR PEAK FINDING
    @on_trait_change('ana_xform, _beam_mask, recompute_good_vox+')
    def _set_recompute_work_arr(self, name, val):
        if name.find('recompute_good_vox') == 0:
            self.recompute_work_arr = self.recompute_good_vox1
##             print 'resetting due to good vox dirt', self.recompute_work_arr
        else:
            self.recompute_work_arr = True

    def work_arr(self):
        if not self.recompute_work_arr:
            return self._work_arr
        self.recompute_work_arr = False
##         print 'recomputing work_arr'
        # this will be a masked array, where the mask is based on whatever
        # beam_mask is, and whatever the "good_vox" are
        gv = np.logical_not(self.good_vox())
##         print 'grabbing beam_mask from work_arr'
        bmask = self.beam_mask
        if bmask is not None:
            m = self.beam_mask | gv[:,None,None]
        else:
##             print 'grabbing beam_sig from work_arr1'
            bsig = self.beam_sig
            rep = np.product(bsig.shape[1:])
            m = gv.repeat(rep).reshape(bsig.shape)
##         print m.shape, gv.shape, m.sum()
##         print 'grabbing beam_sig from work_arr2'
        m_arr = np.ma.masked_array(self.beam_sig, mask=m, copy=False)
        self._work_arr = np.abs(m_arr) if self.ana_xform=='absmax' else m_arr
        return self._work_arr
    
    ## ORDERED INDICES IN VARIOUS DIMENSION PARTITIONS
    @on_trait_change('recompute_work_arr')
    def _set_recompute_orders(self):
        if self.recompute_work_arr:
            self.recompute_all_order = True
            self.recompute_spatial_order = True
            self.recompute_tf_order = True
    
    def ordered_idx_alldim(self):
        """ Create a list of sorted map indices for all dimensions
        """
        if not self.recompute_all_order:
            return self._ordered_idx_alldim
        self.recompute_all_order = False
##         print 'recomputing alldim ordered'
##         print 'grabbing work_arr from ordered_idx_alldim'
        m_arr = self.work_arr()
        sidx = m_arr.flatten().argsort()
        nz = m_arr.mask.flat[sidx].nonzero()[0]
        if nz.shape not in ( (), (0,) ):
            last_good = nz[0]
        else:
            # the mask is all False (meaning all unmasked)
            last_good = len(sidx)    
        self._num_alldim_features = last_good
        self._ordered_idx_alldim = sidx[:last_good]
        return self._ordered_idx_alldim

    def ordered_idx_spatial(self):
        if not self.recompute_spatial_order:
            return self._ordered_idx_spatial
        self.recompute_spatial_order = False
##         print 'recomputing spatial ordered'
        ti, fi = self.tf_idx
##         print 'grabbing work_arr form ordered_idx_spatial'
        m_arr = self.work_arr()[:,ti,fi]
        sidx = m_arr.flatten().argsort()
        nz = m_arr.mask.flat[sidx].nonzero()[0]
        if nz.shape not in ( (), (0,) ):
            last_good = nz[0]
        else:
            # the mask is all False (meaning all unmasked)
            last_good = len(sidx)    
        self._num_spatial_features = last_good
        self._ordered_idx_spatial = sidx[:last_good]
        return self._ordered_idx_spatial

    def ordered_idx_tf(self):
        if not self.recompute_tf_order:
            return self._ordered_idx_tf
        self.recompute_tf_order = False
##         print 'recomputing tf ordered'
        v_idx = self.vox_idx
##         print 'grabbing work_arr from ordered_idx_Tf'
        m_arr = self.work_arr()[v_idx]
        sidx = m_arr.flatten().argsort()
        nz = m_arr.mask.flat[sidx].nonzero()[0]
        if nz.shape not in ( (), (0,) ):
            last_good = nz[0]
        else:
            # the mask is all False (meaning all unmasked)
            last_good = len(sidx)    
        self._num_spatial_features = last_good
        self._ordered_idx_tf = sidx[:last_good]
        return self._ordered_idx_tf
    
    #-------------------------------------------------------------------------
    ### TRAITS CALLBACKS
    def _lbutton_fired(self):
        f = browse_files(None, dialog='Select File',
                         wildcard='*.mat *.npy *.npz')
        if f:
            self.update_beam(f)

    def _rbutton_fired(self):        
        self.beam.reinterpret_signal_as(self.alt_names)
        self.update_beam(self.beam)

    def _pextrabutton_fired(self):
        self._using_extra_map = True
        self.signal_new_image()
##         self.comm_with_listener('signal')

    def _resetsignal_fired(self):
        self._using_extra_map = False
        self.signal_new_image()
##         self.comm_with_listener('signal')

    def _all_button_fired(self):
        self.find_alldim_peak()

    def _spatial_button_fired(self):
        self.find_spatial_peak()

    def _tf_button_fired(self):
        self.find_tf_peak()

    #-------------------------------------------------------------------------
    ### COUPLING WITH LISTENER OBJECT

    def main_xyz_changed(self, *mri_xyz):
        print mri_xyz
        self.vox_idx = self.beam.vox_lookup_from_mr(mri_xyz)

    @on_trait_change('transforms, _beam_mask')
    def signal_new_image(self):
        if self.beam is None:
            return
        self.beam.uses = self.transforms
        # pack a lot of API stuff in here for the time being
        self.overlay = self.to_overlay(*self.tf_idx)
        # fire the Traits Event
        self.overlay_updated = True
        if self._image_signal is not None:
            print 'signalling new image'
            self._image_signal.emit(self)
        # is this needed??
        self.__needs_refresh = False

    def signal_new_vox(self):
        meg_xyz = self.beam.voxels[self.vox_idx]
        mri_xyz = self.beam.coreg.meg2mri(meg_xyz)[0]
        if self._loc_signal is not None:
            self._loc_signal.emit(*mri_xyz)

    @on_trait_change('tf_idx')
    def signal_new_tf(self):
        ti, fi = self.tf_idx
        emitting = (self.beam.timepts[ti],) + tuple(self.beam.bands[fi])
        self.signal_new_image()
        if self._tf_signal is not None:
            self._tf_signal.emit(*emitting)

    #-------------------------------------------------------------------------
    ### UTILITY METHODS
    def alpha(self, scale=1.0):
##         half_alpha_db = 0.5
##         pc = np.polyfit([-half_alpha_db, 0, half_alpha_db],
##                         [192., 64., 192.], 2)

        sig_range = np.linspace(self.norm[0], self.norm[1], 256)
        sig_range[np.argmin(sig_range)] = 0
        sig_range *= (scale * 2*np.pi/max(abs(self.norm[0]), abs(self.norm[1])))

        signal_type = self.stats_map if self._using_extra_map \
                      else self.transforms
        print signal_type, self.fill_value
        if signal_type in ('F dB' 'T test'):
            # de-emphasize 0, emphasize neg and pos
            #f = lambda x: np.polyval(pc, scale*x)
            f = lambda x: np.abs(np.arctan(sig_range)) * (255*2/np.pi)
        elif signal_type == 'F raw':
            # de-emphasize 1, emphasize less than and greater than
            #f = lambda x: np.polyval(pc, 10*np.log10(scale*x))
            sig_range = 10*np.log10(sig_range)
            f = lambda x: np.abs(np.arctan(sig_range)) * (255*2/np.pi)            
        elif signal_type.find('p val') >= 0:
            # ramp down from 255 to 0
            f = lambda x: np.arange(255,-1,-1)*scale
        else:
            # ramp up from 0 to 255
            f = lambda x: np.arange(256)*scale
        a = np.clip(f(sig_range), 0, 255)
        # this should also hide NaNs???
        a[0] = 0
        return a

    ### PEAK FINDING
    @on_trait_change('all_order')
    def find_alldim_peak(self):
##         print 'grabbing ordered_idx_alldim from find_alldim_peak'
        o_idx = self.ordered_idx_alldim()
        if o_idx.shape in ( (), (0,) ):
            print 'no features, all masked'
            return
        if self.ana_xform in ('absmax', 'max'):
            # find the (last-order) unmasked ordered index
            all_pk_idx = o_idx[-self.all_order]
        else:
            # find the lowest order unmasked index
            all_pk_idx = o_idx[self.all_order-1]
##         print 'grabbing beam_sig from find_alldim_peak'
        vx, ti, fi = unravel_index(all_pk_idx, self.beam_sig.shape)

        # update state and send off the new image signal
        self.vox_idx = vx
        self.tf_idx = ti, fi
        self.signal_new_vox()
        self.signal_new_image()
##         self.comm_with_listener(tuple(vox_loc) + (ti, fi))

    @on_trait_change('spatial_order')
    def find_spatial_peak(self):
##         print 'grabbing ordered_idx_spatial from find_spatial_peak'
        o_idx = self.ordered_idx_spatial()
        if o_idx.shape in ( (), (0,) ):
            print 'no features, all masked'
            return
        if self.ana_xform in ('absmax', 'max'):
            # find the (last-order) unmasked ordered index
            spatial_pk_idx = o_idx[-self.spatial_order]
        else:
            # find the lowest order unmasked index
            spatial_pk_idx = o_idx[self.spatial_order-1]

        # update state of vox_idx and send new vox signal
        self.vox_idx = spatial_pk_idx
        self.signal_new_vox()
##         self.comm_with_listener(vox)

    @on_trait_change('tf_order')
    def find_tf_peak(self):
##         print 'grabbing ordered_idx_tf from find_tf_peak'
        o_idx = self.ordered_idx_tf()
        if o_idx.shape in ( (), (0,) ):
            print 'no features, all masked'
            return        
        if self.ana_xform in ('absmax', 'max'):
            tf_pk_idx = o_idx[-self.tf_order]
        else:
            tf_pk_idx = o_idx[self.tf_order-1]
##         print 'grabbing beam_sig from find_tf_peak'
        ti, fi = unravel_index(tf_pk_idx, self.beam_sig.shape[1:])

        # update state of tf_idx and send new image signal
        self.tf_idx = ti, fi
##         self.signal_new_image()
##         self.comm_with_listener((ti,fi))
        
    #-------------------------------------------------------------------------
    ### DATA EXPORT FUNCTIONS
    
    def stats_overlay(self, stat_name):
        """Return a VolumeSlicer type for the requested stats map.
        It is assumed that the map has the same voxel to world mapping
        as the current overlay.

        Parameters
        ----------
        stat_name : str
            The name of the stats mapping to return as a VolumeSlicer type

        Returns
        -------
        a VolumeSlicerInterface subclass (of the same type as the
        current overlay)
        """
        if self.overlay is None:
            print 'Overlay not yet loaded'
            return None
        if stat_name not in self._stats_maps:
            print 'Stats array not loaded:', stat_name
            return None
        oclass = type(self.overlay)
        t, f = self.tf_idx
        vdata = self.stats_map_arrays[stat_name][:,t,f]
        vox = self.beam.voxel_indices
        arr = signal_array_to_masked_vol(
            vdata, vox,
            fill_value=fill_values[stat_name]
            ).filled()
        cmap = self.overlay.coordmap
        bbox = self.overlay.bbox # ???
        return oclass(ni_api.Image(arr, cmap), bbox=bbox)
    
    def to_masked_array(self, t_idx, f_idx, grid_shape=None):
##         print 'grabbing beam_sig from to_masked_array'
        sig = self.beam_sig[:,t_idx,f_idx]
        vox = self.beam.voxel_indices
##         print 'grabbing beam_mask from to_masked_array'
        bmask = self.beam_mask
        if bmask is not None:
            vox_mask = bmask[:,t_idx,f_idx]
            print 'beam_mask pts:', np.logical_not(vox_mask).sum()
            sig = sig[np.logical_not(vox_mask)]
            vox = vox[np.logical_not(vox_mask)]

        m_arr = signal_array_to_masked_vol(sig, vox,
                                           grid_shape=grid_shape,
                                           fill_value=self.fill_value)
        return m_arr
    
    def to_ni_image(self, t_idx, f_idx, grid_shape=None):
        m_arr = self.to_masked_array(t_idx, f_idx, grid_shape=grid_shape,
                                     fill_value=self.fill_value)
        meg2mri = self.beam.coreg.meg2mri
        return ni_api.Image(m_arr.filled(),
                            compose(meg2mri, self.beam.coordmap))

    def to_overlay(self, t_idx, f_idx, grid_spacing=None):
        m_arr = self.to_masked_array(t_idx, f_idx)
        meg2mri = self.beam.coreg.meg2mri
        img = ni_api.Image(m_arr.filled(),
                           compose(meg2mri, self.beam.coordmap))
##         overlay = SampledVolumeSlicer(img, bbox=self.bbox,
##                                       mask=np.logical_not(m_arr.mask),
##                                       grid_spacing=grid_spacing)
        overlay = ResampledVolumeSlicer(img, bbox=self.bbox,
                                        mask=np.logical_not(m_arr.mask),
                                        grid_spacing=grid_spacing)
        return overlay
        
    #-------------------------------------------------------------------------
    ### DATA REFRESH
    def update_beam(self, b):
        try:
            self.beam = load_beam(b)
        except Exception, e:
            print 'could not load beam %s'%repr(b)
            raise e
        print 'beam JUST loaded'
        self.__needs_refresh = True
        self._beam_transforms = self.beam.signal_transforms
        # do this last to hopefully trigger new image signal
        self.transforms = self.beam.uses
        if self.__needs_refresh:
            print 'kicking tardy signal out'
            self.signal_new_image()


    bgroup = VGroup(
        Item('lbutton', show_label=False),
        Item('transforms', label='Beam Transforms', width=40),
        HGroup(Item('alt_names', label='Rename Transform', width=40),
               Item('rbutton', show_label=False),
               visible_when='transforms=="unknown"'),
        HGroup(Item('stats_map', label='Other Stats Maps', width=40),
               Item('pextrabutton', show_label=False),
               visible_when='len(object._stats_maps) > 1'),
        Group(Item('resetsignal', show_label=False),
              visible_when='object._using_extra_map')
        )

    loc_group = VGroup(
        Item('ana_xform', label='Find Features', width=10),
        HGroup(
            Item('all_button', show_label=False),
            Item('all_order', show_label=False, style='simple')
            ),
        HGroup(
            Item('spatial_button', show_label=False),
            Item('spatial_order', show_label=False, style='simple')
            ),
        HGroup(
            Item('tf_button', show_label=False),
            Item('tf_order', show_label=False, style='simple')
            ),
        Item('radius', style='simple',
             label='searched radius (mm)')
        )

                    
    view = View(
        Group(
            HGroup(
                bgroup,
                loc_group,
                ),
            ),
        resizable=True,
        title='Beam Signals List'
        )

if __name__=='__main__':
    pass
    #demo1 = SignalBeamManager([(-100,100)]*3)
    #demo1.bstats_manager.bman = demo1
    #demo = StatsBeamList(demo1)
##     view = View(
##         Group(
##             HGroup(
##                 demo1.bgroup,
##                 demo1.loc_group,
##                 ),
##             demo1.bstats_manager.view_group,
##             layout='tabbed'
##             ),
##         resizable=True,
##         title='Beam Signals List'
##         )
    #demo1.configure_traits(view=view)

